{"version":3,"sources":["webpack://Kuzzle/webpack/universalModuleDefinition","webpack://Kuzzle/webpack/bootstrap","webpack://Kuzzle/./src/controllers/searchResult/base.js","webpack://Kuzzle/./src/controllers/security/user.js","webpack://Kuzzle/./src/eventEmitter/index.js","webpack://Kuzzle/./src/controllers/security/role.js","webpack://Kuzzle/./src/controllers/security/profile.js","webpack://Kuzzle/./src/networkWrapper/protocols/abstract/common.js","webpack://Kuzzle/./src/uuidv4.js","webpack://Kuzzle/./src/networkWrapper/protocols/abstract/realtime.js","webpack://Kuzzle/./src/Kuzzle.js","webpack://Kuzzle/./src/controllers/auth.js","webpack://Kuzzle/./src/controllers/bulk.js","webpack://Kuzzle/./src/controllers/collection.js","webpack://Kuzzle/./src/controllers/searchResult/specifications.js","webpack://Kuzzle/./src/controllers/document.js","webpack://Kuzzle/./src/controllers/searchResult/document.js","webpack://Kuzzle/./src/controllers/index.js","webpack://Kuzzle/./src/controllers/realtime/index.js","webpack://Kuzzle/./src/controllers/realtime/room.js","webpack://Kuzzle/./src/controllers/server.js","webpack://Kuzzle/./src/controllers/security/index.js","webpack://Kuzzle/./src/controllers/searchResult/role.js","webpack://Kuzzle/./src/controllers/searchResult/profile.js","webpack://Kuzzle/./src/controllers/searchResult/user.js","webpack://Kuzzle/./src/controllers/memoryStorage.js","webpack://Kuzzle/./src/networkWrapper/index.js","webpack://Kuzzle/./src/networkWrapper/protocols/http.js","webpack://Kuzzle/./src/networkWrapper/protocols/websocket.js","webpack://Kuzzle/./src/networkWrapper/protocols/socketio.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","[object Object]","kuzzle","request","options","response","this","hits","fetched","length","total","controller","searchAction","scrollAction","Promise","resolve","scroll","query","assign","action","scrollId","then","size","sort","search_after","hit","push","_source","keys","from","Error","_kuzzle","_id","content","meta","profileIds","security","mGetProfiles","Listener","fn","once","_events","listeners","Boolean","find","listener","eventName","undefined","map","listenerType","_exists","addListener","concat","addOnceListener","prependListener","index","findIndex","splice","payload","onceListeners","toDelete","removeListener","controllers","policies","mGetRoles","policy","roleId","uuidv4","KuzzleEventEmitter","_host","_port","_ssl","AbstractWrapper","super","host","port","sslConnection","autoReplay","autoQueue","offlineQueue","offlineQueueLoader","queueFilter","queueMaxSize","queueTTL","queuing","replayInterval","state","forEach","opt","getOwnPropertyDescriptor","writable","id","ssl","wasConnected","emit","stopQueuing","playQueue","startQueuing","isReady","_cleanQueue","_dequeue","queuable","reject","ts","Date","now","_emitRequest","JSON","stringify","lastDocumentIndex","droppedRequest","uniqueQueue","dequeuingProcess","catch","shift","setTimeout","Math","max","additionalQueue","Array","isArray","filter","requestId","error","message","status","send","prop","b","a","random","toString","replace","RTWrapper","_autoReconnect","autoReconnect","_reconnectionDelay","reconnectionDelay","offlineMode","stopRetryingToConnect","retrying","clientConnected","connectionError","internal","connect","AuthController","BulkController","CollectionController","DocumentController","IndexController","RealtimeController","ServerController","SecurityController","MemoryStorageController","networkWrapper","events","Kuzzle","network","method","_protectedEvents","connected","disconnected","reconnected","tokenExpired","loginAttempt","autoResubscribe","eventTimeout","sdkVersion","volatile","auth","bulk","collection","document","ms","realtime","server","data","err","jwt","_checkPropertyType","_jwt","token","result","protectedEvent","lastEmitted","checkToken","res","valid","event","indexOf","flushQueue","close","refresh","item","sdkInstanceId","typestr","User","body","strategy","credentials","_meta","expiresIn","success","bulkData","SpecificationsSearchResult","SearchResultBase","DocumentSearchResult","includeTrash","count","documents","ids","retryOnConflict","indexes","autoRefresh","Room","subscriptions","filters","channels","roomId","callback","room","subscribe","rooms","removeListeners","channel","subscribeToSelf","_channelListener","_reSubscribeListener","on","fromSelf","exists","startTime","stopTime","Role","RoleSearchResult","Profile","ProfileSearchResult","UserSearchResult","reset","next","getId","required","getIdField","getKeys","getMember","getxScan","opts","mapResults","mapScanResults","getZrange","assignZrangeOptions","mapZrangeResults","getZrangeBy","setId","setIdValue","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","mapNoResult","geoadd","geodist","parseFloat","geohash","geopos","results","coords","georadius","assignGeoRadiusOptions","mapGeoRadiusResults","georadiusbymember","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","set","setex","setnx","sinter","sinterstore","sismember","smembers","smove","spop","mapStringToArray","srandmember","srem","sscan","strlen","sunion","sunionstore","time","x","parseInt","touch","ttl","type","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","args","command","param","assignParameter","parsed","limit","point","elem","coordinates","distance","mapped","member","score","cursor","values","protocol","WebSocket","io","AbtractWrapper","_routes","routes","login","verb","url","import","createFirstAdmin","createRestrictedUser","createUser","HttpWrapper","http","customRoutes","_sendHttpRequest","serverInfo","api","headers","Content-Type","queryArgs","authorization","Buffer","byteLength","route","regex","matches","exec","queryString","v","join","path","XMLHttpRequest","httpClient","e","code","parse","xhr","open","header","setRequestHeader","onload","json","responseText","WebSocketClient","client","lasturl","perMessageDeflate","onopen","onclose","closeEvent","reason","clientDisconnected","clientNetworkError","onerror","CLOSING","CLOSED","readyState","onmessage","OPEN","removeAllListeners","socket","forceDisconnect","eventsWrapper","reconnection","forceNew","_addEventWrapper","delete","off","wrapper","_event","Set","add"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","class SearchResultBase {\n\n  /**\n   *\n   * @param {Kuzzle} kuzzle\n   * @param {object} request\n   * @param {object} options\n   * @param {object} response\n   */\n  constructor (kuzzle, request = {}, options = {}, response = {}) {\n    this.kuzzle = kuzzle;\n    this.request = request;\n    this.options = options;\n    this.response = response;\n\n    this.hits = response.hits || [];\n    this.fetched = this.hits.length;\n    this.total = response.total || 0;\n\n    this.controller = request.controller;\n    this.searchAction = 'search';\n    this.scrollAction = 'scroll';\n  }\n\n  next () {\n    if (this.fetched >= this.total) {\n      return Promise.resolve(null);\n    }\n\n    if (this.request.scroll) {\n      return this.kuzzle.query(Object.assign({}, this.request, {\n        action: this.scrollAction,\n        scrollId: this.response.scrollId\n      }), this.options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          this.hits = r.hits;\n          return this;\n        });\n    }\n\n    if (this.request.size && this.request.sort) {\n      const\n        request = Object.assign({}, this.request, {\n          action: this.searchAction,\n          search_after: []\n        }),\n        hit = this.response.hits && this.response.hits[this.response.hits.length -1];\n\n      for (const sort of this.request.sort) {\n        if (typeof sort === 'string') {\n          request.search_after.push(hit._source[sort]);\n        }\n        else {\n          request.search_after.push(hit._source[Object.keys(sort)[0]]);\n        }\n      }\n\n      return this.kuzzle.query(request, this.options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          this.hits = r.hits;\n          return this;\n        });\n    }\n\n    if (this.request.from && this.request.size) {\n      if (this.request.from >= this.response.total) {\n        return Promise.resolve(null);\n      }\n\n      return this.kuzzle.query(Object.assign({}, this.request, {\n        action: this.searchAction,\n        from: this.fetched\n      }), this.options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          this.hits = r.hits;\n          return this;\n        });\n    }\n\n    throw new Error('Unable to retrieve next results from search: missing scrollId, from/sort, or from/size params');\n  }\n}\n\nmodule.exports = SearchResultBase;\n","let\n  _kuzzle;\n\nclass User {\n  /**\n   *\n   * @param {Kuzzle} kuzzle\n   * @param {Object} data\n   */\n  constructor (kuzzle, _id = null, content = {}, meta = {}) {\n    _kuzzle = kuzzle;\n\n    this._id = _id;\n    this.content = content;\n    this.meta = meta;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  get profileIds () {\n    return this.content.profileIds || [];\n  }\n\n  /**\n   * @returns {Promise<[Profile]>}\n   */\n  getProfiles () {\n    if (!this.profileIds || this.profileIds.length === 0) {\n      return Promise.resolve([]);\n    }\n    return this.kuzzle.security.mGetProfiles(this.profileIds);\n  }\n\n}\n\nmodule.exports = User;\n\n","class Listener {\n  constructor(fn, once = false) {\n    this.fn = fn;\n    this.once = once;\n  }\n}\n\nclass KuzzleEventEmitter {\n  constructor() {\n    this._events = {};\n  }\n\n  _exists (listeners, fn) {\n    return Boolean(listeners.find(listener => listener.fn === fn));\n  }\n\n  listeners (eventName) {\n    if (this._events[eventName] === undefined) {\n      return [];\n    }\n\n    return this._events[eventName].map(listener => listener.fn);\n  }\n\n  addListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    const listenerType = typeof listener;\n\n    if (listenerType !== 'function') {\n      throw new Error(`Invalid listener type: expected a function, got a ${listenerType}`);\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName].push(new Listener(listener, once));\n    }\n\n    return this;\n  }\n\n  on (eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  prependListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n    }\n\n    return this;\n  }\n\n  addOnceListener (eventName, listener) {\n    return this.addListener(eventName, listener, true);\n  }\n\n  once (eventName, listener) {\n    return this.addOnceListener(eventName, listener);\n  }\n\n  prependOnceListener (eventName, listener) {\n    return this.prependListener(eventName, listener, true);\n  }\n\n  removeListener (eventName, listener) {\n    const listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n\n    const index = listeners.findIndex(l => l.fn === listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    return this;\n  }\n\n  removeAllListeners (eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  }\n\n  emit (eventName, ...payload) {\n    const listeners = this._events[eventName];\n\n    if (listeners === undefined) {\n      return false;\n    }\n\n    const onceListeners = [];\n\n    for (const listener of listeners) {\n      listener.fn(...payload);\n\n      if (listener.once) {\n        onceListeners.push(listener.fn);\n      }\n    }\n\n    for (const toDelete of onceListeners) {\n      this.removeListener(eventName, toDelete);\n    }\n\n    return true;\n  }\n\n  eventNames () {\n    return Object.keys(this._events);\n  }\n\n  listenerCount (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  }\n}\n\nmodule.exports = KuzzleEventEmitter;\n","let _kuzzle;\n\nclass Role {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   * @param {Object} data\n   */\n  constructor (kuzzle, _id = null, controllers = {}) {\n    _kuzzle = kuzzle;\n\n    this._id = _id;\n    this.controllers = controllers;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n}\n\nmodule.exports = Role;\n\n","let _kuzzle;\n\nclass Profile {\n  /**\n   *\n   * @param {Kuzzle} kuzzle\n   * @param {Object} data\n   */\n  constructor (kuzzle, _id = null, policies = []) {\n    _kuzzle = kuzzle;\n\n    this._id = _id;\n    this.policies = policies;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n\n  /**\n   * @returns {Promise<[Role]>}\n   */\n  getRoles (options = {}) {\n    if (!this.policies || this.policies.length === 0) {\n      return Promise.resolve([]);\n    }\n    return this.kuzzle.security.mGetRoles(this.policies.map(policy => policy.roleId), options);\n  }\n}\n\nmodule.exports = Profile;\n\n","'use strict';\n\nconst\n  uuidv4 = require('../../../uuidv4'),\n  KuzzleEventEmitter = require('../../../eventEmitter');\n\nconst\n  _id = uuidv4();\n// read-only properties\nlet\n  _host,\n  _port,\n  _ssl;\n\nclass AbstractWrapper extends KuzzleEventEmitter {\n\n  constructor (options = {}) {\n    super();\n\n    _host = options.host;\n    _port = typeof options.port === 'number' ? options.port : 7512;\n    _ssl = typeof options.sslConnection === 'boolean' ? options.sslConnection : false;\n\n    this.autoReplay = false;\n    this.autoQueue = false;\n    this.offlineQueue = [];\n    this.offlineQueueLoader = null;\n    this.queueFilter = null;\n    this.queueMaxSize = 500;\n    this.queueTTL = 120000;\n    this.queuing = false;\n    this.replayInterval = 10;\n    this.state = 'offline';\n\n    Object.keys(options).forEach(opt => {\n      if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n        this[opt] = options[opt];\n      }\n    });\n  }\n\n  get id () {\n    return _id;\n  }\n\n  get host () {\n    return _host;\n  }\n\n  get port () {\n    return _port;\n  }\n\n  get ssl () {\n    return _ssl;\n  }\n\n  /**\n   * @abstract\n   * @returns {Promise<any>}\n   */\n  connect () {\n    throw new Error('Method \"connect\" is not implemented');\n  }\n\n  /**\n   * @abstract\n   * @param request\n   * @returns {Promise<any>}\n   */\n  send () {\n    throw new Error('Method \"send\" is not implemented');\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected (state, wasConnected) {\n    this.state = state || 'ready';\n    this.emit(wasConnected && 'reconnect' || 'connect');\n\n    if (this.autoQueue) {\n      this.stopQueuing();\n    }\n\n    if (this.autoReplay) {\n      this.playQueue();\n    }\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  close () {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   */\n  flushQueue () {\n    this.offlineQueue = [];\n  }\n\n  /**\n   * Replays the requests queued during offline mode.\n   */\n  playQueue () {\n    if (this.isReady()) {\n      this._cleanQueue();\n      this._dequeue();\n    }\n  }\n\n  /**\n   * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  startQueuing () {\n    this.queuing = true;\n  }\n\n  /**\n   * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  stopQueuing () {\n    this.queuing = false;\n  }\n\n  query (request, options) {\n    let queuable = options && (options.queuable !== false) || true;\n\n    if (this.queueFilter) {\n      queuable = queuable && this.queueFilter(request);\n    }\n\n    if (this.queuing && queuable) {\n      this._cleanQueue();\n      this.emit('offlineQueuePush', {request});\n      return new Promise((resolve, reject) => {\n        this.offlineQueue.push({\n          resolve,\n          reject,\n          request,\n          ts: Date.now()\n        });\n      });\n    }\n\n    if (this.isReady()) {\n      return this._emitRequest(request);\n    }\n\n    return Promise.reject(new Error(`Unable to execute request: not connected to a Kuzzle server.\nDiscarded request: ${JSON.stringify(request)}`));\n  }\n\n  isReady () {\n    return this.state === 'ready';\n  }\n\n  /**\n   * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n   */\n  _cleanQueue () {\n    const now = Date.now();\n    let lastDocumentIndex = -1;\n\n    if (this.queueTTL > 0) {\n      this.offlineQueue.forEach((query, index) => {\n        if (query.ts < now - this.queueTTL) {\n          lastDocumentIndex = index;\n        }\n      });\n\n      if (lastDocumentIndex !== -1) {\n        this.offlineQueue\n          .splice(0, lastDocumentIndex + 1)\n          .forEach(droppedRequest => {\n            this.emit('offlineQueuePop', droppedRequest.query);\n          });\n      }\n    }\n\n    if (this.queueMaxSize > 0 && this.offlineQueue.length > this.queueMaxSize) {\n      this.offlineQueue\n        .splice(0, this.offlineQueue.length - this.queueMaxSize)\n        .forEach(droppedRequest => {\n          this.emit('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  /**\n   * Play all queued requests, in order.\n   */\n  _dequeue () {\n    const\n      uniqueQueue = {},\n      dequeuingProcess = () => {\n        if (this.offlineQueue.length > 0) {\n          this._emitRequest(this.offlineQueue[0].request)\n            .then(this.offlineQueue[0].resolve)\n            .catch(this.offlineQueue[0].reject);\n          this.emit('offlineQueuePop', this.offlineQueue.shift());\n\n          setTimeout(() => {\n            dequeuingProcess();\n          }, Math.max(0, this.replayInterval));\n        }\n      };\n\n    if (this.offlineQueueLoader) {\n      if (typeof this.offlineQueueLoader !== 'function') {\n        throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof this.offlineQueueLoader);\n      }\n\n      const additionalQueue = this.offlineQueueLoader();\n      if (Array.isArray(additionalQueue)) {\n        this.offlineQueue = additionalQueue\n          .concat(this.offlineQueue)\n          .filter(query => {\n            // throws if the request does not contain required attributes\n            if (!query.request || query.request.requestId === undefined || !query.request.action || !query.request.controller) {\n              throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n            }\n\n            return uniqueQueue.hasOwnProperty(query.request.requestId) ? false : (uniqueQueue[query.request.requestId] = true);\n          });\n      } else {\n        throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n      }\n    }\n\n    dequeuingProcess();\n  }\n\n  _emitRequest (request) {\n    return new Promise((resolve, reject) => {\n      this.once(request.requestId, response => {\n        if (response.error) {\n          const error = new Error(response.error.message);\n          Object.assign(error, response.error);\n          error.status = response.status;\n          response.error = error;\n          this.emit('queryError', error, request);\n\n          if (request.action !== 'logout' && error.message === 'Token expired') {\n            this.emit('tokenExpired');\n          }\n\n          return reject(error);\n        }\n\n        return resolve(response);\n      });\n\n      this.send(request);\n    });\n  }\n}\n\n// make public getters enumerable\nfor (const prop of [\n  'host',\n  'id',\n  'port',\n  'ssl'\n]) {\n  Object.defineProperty(AbstractWrapper.prototype, prop, {enumerable: true});\n}\n\nmodule.exports = AbstractWrapper;\n","// golfed version of uuid-v4\n// uuid node module relies on crypto, which is a bit fat to embed\n//\n// cf amazing https://gist.github.com/jed/982883\n\nconst b = (a) => a\n  ? (\n    a ^\n    Math.random()\n    * 16\n    >> a/4\n  ).toString(16)\n  : (\n    [1e7] +\n    -1e3 +\n    -4e3 +\n    -8e3 +\n    -1e11\n  ).replace(\n    /[018]/g,\n    b\n  );\n\nmodule.exports = b;\n","'use strict';\n\nconst\n  AbstractWrapper = require('./common');\n\nclass RTWrapper extends AbstractWrapper {\n\n  constructor (options = {}) {\n    super(options);\n\n    this._autoReconnect = typeof options.autoReconnect === 'boolean' ? options.autoReconnect : true;\n    this._reconnectionDelay = typeof options.reconnectionDelay === 'number' ? options.reconnectionDelay : 1000;\n\n    if (options.offlineMode === 'auto' && this.autoReconnect) {\n      this.autoQueue = true;\n      this.autoReplay = true;\n    }\n\n    this.wasConnected = false;\n    this.stopRetryingToConnect = false;\n    this.retrying = false;\n  }\n\n  get autoReconnect () {\n    return this._autoReconnect;\n  }\n\n  get reconnectionDelay () {\n    return this._reconnectionDelay;\n  }\n\n  connect() {\n    this.state = 'connecting';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected() {\n    super.clientConnected('connected', this.wasConnected);\n\n    this.state = 'connected';\n    this.wasConnected = true;\n    this.stopRetryingToConnect = false;\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  clientDisconnected() {\n    this.emit('disconnect');\n  }\n\n  /**\n   * Called when the client's connection is closed with an error state\n   *\n   * @param {Error} error\n   */\n  clientNetworkError(error) {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    const connectionError = new Error(`Unable to connect to kuzzle server at ${this.host}:${this.port}`);\n    connectionError.internal = error;\n\n    this.emit('networkError', connectionError);\n    if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n      this.retrying = true;\n      setTimeout(() => {\n        this.retrying = false;\n        this.connect(this.host);\n      }, this.reconnectionDelay);\n    } else {\n      this.emit('disconnect');\n    }\n  }\n\n  isReady() {\n    return this.state === 'connected';\n  }\n}\n\n// make public properties enumerable\nfor (const prop of [\n  'autoReconnect',\n  'reconnectionDelay'\n]) {\n  Object.defineProperty(RTWrapper.prototype, prop, {enumerable: true});\n}\n\nmodule.exports = RTWrapper;\n","const\n  KuzzleEventEmitter = require('./eventEmitter'),\n  AuthController = require('./controllers/auth'),\n  BulkController = require('./controllers/bulk'),\n  CollectionController = require('./controllers/collection'),\n  DocumentController = require('./controllers/document'),\n  IndexController = require('./controllers/index'),\n  RealtimeController = require('./controllers/realtime'),\n  ServerController = require('./controllers/server'),\n  SecurityController = require('./controllers/security'),\n  MemoryStorageController = require('./controllers/memoryStorage'),\n  networkWrapper = require('./networkWrapper'),\n  uuidv4 = require('./uuidv4');\n\nconst\n  events = [\n    'connected',\n    'discarded',\n    'disconnected',\n    'loginAttempt',\n    'networkError',\n    'offlineQueuePush',\n    'offlineQueuePop',\n    'queryError',\n    'reconnected',\n    'tokenExpired'\n  ];\n\nclass Kuzzle extends KuzzleEventEmitter {\n\n  /**\n   * @param network - the network wrapper to use. if the argument is a string, creates an embeed network wrapper if a\n   * @param [options] - Connection options\n   */\n  constructor(network, options = {}) {\n    super();\n\n    if (network === undefined || network === null) {\n      throw new Error('\"network\" argument missing');\n    }\n\n    // embedded network protocol (http/websocket/socketio):\n    if (typeof network === 'string') {\n      return new Kuzzle(networkWrapper(network, options), options);\n    }\n\n    // custom protocol: check the existence of required methods\n    for (const method of ['addListener', 'isReady', 'query']) {\n      if (typeof network[method] !== 'function') {\n        throw new Error(`Network instance must implement a \"${method}\" method`);\n      }\n    }\n    this.network = network;\n\n    this._protectedEvents = {\n      connected: {},\n      error: {},\n      disconnected: {},\n      reconnected: {},\n      tokenExpired: {},\n      loginAttempt: {}\n    };\n\n    this.autoResubscribe = typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true;\n    this.eventTimeout = typeof options.eventTimeout === 'number' ? options.eventTimeout : 200;\n    this.sdkVersion = typeof SDKVERSION === 'undefined' ? require('../package').version : SDKVERSION;\n    this.volatile = typeof options.volatile === 'object' ? options.volatile : {};\n\n    // controllers\n    this.auth = new AuthController(this);\n    this.bulk = new BulkController(this);\n    this.collection = new CollectionController(this);\n    this.document = new DocumentController(this);\n    this.index = new IndexController(this);\n    this.ms = new MemoryStorageController(this);\n    this.realtime = new RealtimeController(this);\n    this.security = new SecurityController(this);\n    this.server = new ServerController(this);\n\n    this.network.addListener('offlineQueuePush', data => this.emit('offlineQueuePush', data));\n    this.network.addListener('offlineQueuePop', data => this.emit('offlineQueuePop', data));\n    this.network.addListener('queryError', (err, query) => this.emit('queryError', err, query));\n\n    this.network.addListener('tokenExpired', () => {\n      this.jwt = undefined;\n      this.emit('tokenExpired');\n    });\n  }\n\n  get autoQueue () {\n    return this.network.autoQueue;\n  }\n\n  set autoQueue (value) {\n    this._checkPropertyType('autoQueue', 'boolean', value);\n    this.network.autoQueue = value;\n  }\n\n  get autoReconnect () {\n    return this.network.autoReconnect;\n  }\n\n  set autoReconnect (value) {\n    this._checkPropertyType('autoReconnect', 'boolean', value);\n    this.network.autoReconnect = value;\n  }\n\n  get autoReplay () {\n    return this.network.autoReplay;\n  }\n\n  set autoReplay (value) {\n    this._checkPropertyType('autoReplay', 'boolean', value);\n    this.network.autoReplay = value;\n  }\n\n  get jwt () {\n    return this._jwt;\n  }\n\n  set jwt (token) {\n    if (token === undefined || token === null) {\n      this._jwt = undefined;\n    }\n    else if (typeof token === 'string') {\n      this._jwt = token;\n    }\n    else if (typeof token === 'object'\n      && token.result\n      && token.result.jwt\n      && typeof token.result.jwt === 'string'\n    ) {\n      this._jwt = token.result.jwt;\n    } else {\n      throw new Error(`Invalid token argument: ${token}`);\n    }\n  }\n\n  get host () {\n    return this.network.host;\n  }\n\n  get offlineQueue () {\n    return this.network.offlineQueue;\n  }\n\n  get offlineQueueLoader () {\n    return this.network.offlineQueueLoader;\n  }\n\n  set offlineQueueLoader (value) {\n    this._checkPropertyType('offlineQueueLoader', 'function', value);\n    this.network.offlineQueueLoader = value;\n  }\n\n  get port () {\n    return this.network.port;\n  }\n\n  get queueFilter () {\n    return this.network.queueFilter;\n  }\n\n  set queueFilter (value) {\n    this._checkPropertyType('queueFilter', 'function', value);\n    this.network.queueFilter = value;\n  }\n\n  get queueMaxSize () {\n    return this.network.queueMaxSize;\n  }\n\n  set queueMaxSize (value) {\n    this._checkPropertyType('queueMaxSize', 'number', value);\n    this.network.queueMaxSize = value;\n  }\n\n  get queueTTL () {\n    return this.network.queueTTL;\n  }\n\n  set queueTTL (value) {\n    this._checkPropertyType('queueTTL', 'number', value);\n    this.network.queueTTL = value;\n  }\n\n  get reconnectionDelay () {\n    return this.network.reconnectionDelay;\n  }\n\n  get replayInterval () {\n    return this.network.replayInterval;\n  }\n\n  set replayInterval (value) {\n    this._checkPropertyType('replayInterval', 'number', value);\n    this.network.replayInterval = value;\n  }\n\n  get sslConnection () {\n    return this.network.sslConnection;\n  }\n\n  /**\n  * Emit an event to all registered listeners\n  * An event cannot be emitted multiple times before a timeout has been reached.\n  */\n  emit (eventName, ...payload) {\n    const\n      now = Date.now(),\n      protectedEvent = this._protectedEvents[eventName];\n\n    if (protectedEvent) {\n      if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - this.eventTimeout) {\n        return false;\n      }\n      protectedEvent.lastEmitted = now;\n    }\n\n    super.emit(eventName, ...payload);\n  }\n\n  /**\n   * Connects to a Kuzzle instance using the provided host name\n   * @returns {Promise<Object>}\n   */\n  connect () {\n    if (this.network.isReady()) {\n      return Promise.resolve();\n    }\n\n    this.network.addListener('connect', () => {\n      this.emit('connected');\n    });\n\n    this.network.addListener('networkError', error => {\n      this.emit('networkError', error);\n    });\n\n    this.network.addListener('disconnect', () => {\n      this.emit('disconnected');\n    });\n\n    this.network.addListener('reconnect', () => {\n      if (this.jwt) {\n        this.checkToken(this.jwt, (err, res) => {\n          // shouldn't obtain an error but let's invalidate the token anyway\n          if (err || !res.valid) {\n            this.jwt = undefined;\n          }\n\n          this.emit('reconnected');\n        });\n      } else {\n        this.emit('reconnected');\n      }\n    });\n\n    this.network.addListener('discarded', data => this.emit('discarded', data));\n\n    return this.network.connect();\n  }\n\n  /**\n   * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n   * insertion.\n   *\n   * @param {string} event - name of the global event to subscribe to\n   * @param {function} listener - callback to invoke each time an event is fired\n   */\n  addListener (event, listener) {\n    if (events.indexOf(event) === -1) {\n      throw new Error(`[${event}] is not a known event. Known events: ${events.toString()}`);\n    }\n\n    return super.addListener(event, listener);\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   *\n   * @returns {Kuzzle}\n   */\n  flushQueue () {\n    this.network.flushQueue();\n    return this;\n  }\n\n  /**\n   * Disconnects from Kuzzle and invalidate this instance.\n   */\n  disconnect () {\n    this.network.close();\n  }\n\n  /**\n   * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n   * Base method used to send read queries to Kuzzle\n   *\n   * Takes an optional argument object with the following properties:\n   *    - volatile (object, default: null):\n   *        Additional information passed to notifications to other users\n   *\n   * @param {object} request\n   * @param {object} [options] - Optional arguments\n   * @returns {Promise<object>}\n   */\n  query (request = {}, options = {}) {\n    if (typeof request !== 'object' || Array.isArray(request)) {\n      throw new Error(`Kuzzle.query: Invalid request: ${JSON.stringify(request)}`);\n    }\n\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(`Kuzzle.query: Invalid \"options\" argument: ${JSON.stringify(options)}`);\n    }\n\n    if (!request.requestId) {\n      request.requestId = uuidv4();\n    }\n\n    // we follow the api but allow some more logical \"mistakes\" (the only allowed value for refresh arg is \"wait_for\")\n    if (request.refresh) {\n      request.refresh = 'wait_for';\n    }\n\n    if (!request.volatile) {\n      request.volatile = this.volatile;\n    } else if (typeof request.volatile !== 'object' || Array.isArray(request.volatile)) {\n      throw new Error(`Kuzzle.query: Invalid volatile argument received: ${JSON.stringify(request.volatile)}`);\n    }\n    for (const item of Object.keys(this.volatile)) {\n      if (request.volatile[item] === undefined) {\n        request.volatile[item] = this.volatile[item];\n      }\n    }\n    request.volatile.sdkInstanceId = this.network.id;\n    request.volatile.sdkVersion = this.sdkVersion;\n\n    /*\n     * Do not add the token for the checkToken route, to avoid getting a token error when\n     * a developer simply wish to verify his token\n     */\n    if (this.jwt !== undefined\n      && request.controller !== 'auth'\n      && request.action !== 'checkToken'\n    ) {\n      request.jwt = this.jwt;\n    }\n\n    return this.network.query(request, options)\n      .then(response => response.result);\n  }\n\n  /**\n   * Starts the requests queuing.\n   */\n  startQueuing () {\n    this.network.startQueuing();\n    return this;\n  }\n\n  /**\n   * Stops the requests queuing.\n   */\n  stopQueuing () {\n    this.network.stopQueuing();\n    return this;\n  }\n\n  /**\n   * @DEPRECATED\n   * See Kuzzle.prototype.playQueue();\n   */\n  replayQueue () {\n    return this.playQueue();\n  }\n\n  /**\n   * Plays the requests queued during offline mode.\n   */\n  playQueue () {\n    this.network.playQueue();\n    return this;\n  }\n\n  _checkPropertyType (prop, typestr, value) {\n    const wrongType = typestr === 'array' ? !Array.isArray(value) : typeof value !== typestr;\n\n    if (wrongType) {\n      throw new Error(`Expected ${prop} to be a ${typestr}, ${typeof value} received`);\n    }\n  }\n}\n\n\nfor (const prop of [\n  'autoQueue',\n  'autoReconnect',\n  'autoReplay',\n  'jwt',\n  'host',\n  'offlineQueue',\n  'offlineQueueLoader',\n  'port',\n  'queueFilter',\n  'queueMaxSize',\n  'queueTTL',\n  'reconnectionDelay',\n  'replayInterval',\n  'sslConnection'\n]) {\n  Object.defineProperty(Kuzzle.prototype, prop, {enumerable: true});\n}\n\nmodule.exports = Kuzzle;\n","const User = require('./security/user');\n\nconst _kuzzle = Symbol();\n\n/**\n * Auth controller\n *\n * @param kuzzle\n * @constructor\n */\nclass AuthController {\n\n  /**\n   * constructor\n   * @param kuzzle\n   */\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n\n  /**\n   * Checks whether a given jwt token still represents a valid session in Kuzzle.\n   *\n   * @param  {string}   token     The jwt token to check\n   * @return {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  checkToken (token) {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'checkToken',\n      body: {token}\n    }, {queuable: false});\n  }\n\n  /**\n   * Create credentials of the specified <strategy> for the current user.\n   *\n   * @param credentials\n   * @param strategy\n   * @param options\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  createMyCredentials (strategy, credentials, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'auth',\n      action: 'createMyCredentials',\n      body: credentials\n    }, options);\n  }\n\n  /**\n   * Check the existence of the specified <strategy>'s credentials for the current user.\n   *\n   * @param strategy\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  credentialsExist (strategy, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'auth',\n      action: 'credentialsExist'\n    }, options);\n  }\n\n  /**\n   * Delete credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  deleteMyCredentials (strategy, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'auth',\n      action: 'deleteMyCredentials'\n    }, options);\n  }\n\n  /**\n   * Fetches the current user.\n   *\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  getCurrentUser (options = {}) {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'getCurrentUser'\n    }, options)\n      .then(result => new User(this.kuzzle, result._id, result._source, result._meta));\n  }\n\n  /**\n   * Get credential information of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  getMyCredentials(strategy, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'auth',\n      action: 'getMyCredentials'\n    }, options);\n  }\n\n  /**\n   * Gets the rights array of the currently logged user.\n   *\n   * @param {object} [options] - Optional parameters\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  getMyRights (options = {}) {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'getMyRights'\n    }, options)\n      .then(res => res.hits);\n  }\n\n  /**\n   * Get all the strategies registered in Kuzzle by all auth plugins\n   *\n   * @param {object} [options] - Optional parameters\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  getStrategies (options = {}) {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'getStrategies'\n    }, options);\n  }\n\n  /**\n   * Send login request to kuzzle with credentials\n   * If login success, store the jwt into kuzzle object\n   *\n   * @param strategy\n   * @param credentials\n   * @param expiresIn\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  login (strategy, credentials, expiresIn) {\n    if (typeof strategy !== 'string' || strategy === '') {\n      throw new Error('Kuzzle.auth.login: strategy is required');\n    }\n\n    const\n      request = {\n        strategy,\n        expiresIn,\n        body: credentials || {},\n        controller: 'auth',\n        action: 'login'\n      };\n\n    return this.kuzzle.query(request, {queuable: false})\n      .then(result => {\n        try {\n          this.kuzzle.jwt = result.jwt;\n          this.kuzzle.emit('loginAttempt', {success: true});\n        }\n        catch (err) {\n          return Promise.reject(err);\n        }\n        return result.jwt;\n      })\n      .catch(err => {\n        this.kuzzle.emit('loginAttempt', {success: false, error: err.message});\n        throw err;\n      });\n  }\n\n  /**\n   * Send logout request to kuzzle with jwt.\n   *\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  logout () {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'logout'\n    }, {queuable: false})\n      .then(() => {\n        this.kuzzle.jwt = undefined;\n      });\n  }\n\n  /**\n   * Update credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentals\n   * @param options\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  updateMyCredentials (strategy, credentials, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      body: credentials,\n      controller: 'auth',\n      action: 'updateMyCredentials'\n    }, options);\n  }\n\n  /**\n   * Update current user in Kuzzle.\n   *\n   * @param {object} body - a plain javascript object representing the user's modification\n   * @param {object} [options] - (optional) arguments\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  updateSelf (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'auth',\n      action: 'updateSelf'\n    }, options);\n  }\n\n  /**\n   * Validate credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentials\n   * @param options\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  validateMyCredentials (strategy, credentials, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      body: credentials,\n      controller: 'auth',\n      action: 'validateMyCredentials'\n    }, options);\n  }\n\n}\n\nmodule.exports = AuthController;\n","const _kuzzle = Symbol();\n\nclass BulkController {\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n\n  import (data, options) {\n    return this.kuzzle.query({\n      controller: 'bulk',\n      action: 'import',\n      body: {\n        bulkData: data\n      }\n    }, options);\n  }\n\n}\n\nmodule.exports = BulkController;\n","const\n  SpecificationsSearchResult = require('./searchResult/specifications');\n\nconst _kuzzle = Symbol();\n\nclass CollectionController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n\n  create (index, collection, body = {}, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.create: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.collection.create: collection is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'collection',\n      action: 'create'\n    }, options);\n  }\n\n  deleteSpecification (index, collection, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.deleteSpecification: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.collection.deleteSpecification: collection is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'deleteSpecification'\n    }, options);\n  }\n\n  exists (index, collection, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.exists: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.collection.exists: collection is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'exists'\n    }, options);\n  }\n\n  getMapping (index, collection, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.getMapping: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.collection.getMapping: collection is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'getMapping'\n    }, options);\n  }\n\n  getSpecifications (index, collection, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.getSpecifications: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.collection.getSpecifications: collection is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'getSpecifications'\n    }, options);\n  }\n\n  list (index, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.list: index is required');\n    }\n\n    const request = {\n      index,\n      controller: 'collection',\n      action: 'list',\n      from: options.from,\n      size: options.size\n    };\n    delete options.from;\n    delete options.size;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  searchSpecifications (body = {}, options = {}) {\n    const request = {\n      body,\n      controller: 'collection',\n      action: 'searchSpecifications'\n    };\n    for (const opt of ['from', 'size', 'scroll']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(response => new SpecificationsSearchResult(this.kuzzle, request, options, response));\n  }\n\n  truncate (index, collection, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.truncate: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.collection.truncate: collection is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'truncate'\n    }, options);\n  }\n\n  updateMapping (index, collection, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.updateMapping: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.collection.updateMapping: collection is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'collection',\n      action: 'updateMapping'\n    }, options);\n  }\n\n  updateSpecifications (index, collection, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.collection.updateSpecifications: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.collection.updateSpecifications: collection is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'collection',\n      action: 'updateSpecifications'\n    }, options);\n  }\n\n  validateSpecifications (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'collection',\n      action: 'validateSpecifications'\n    }, options);\n  }\n}\n\nmodule.exports = CollectionController;\n","const SearchResultBase = require('./base');\n\nclass SpecificationsSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.controller = 'collection';\n    this.searchAction = 'searchSpecifications';\n    this.scrollAction = 'scrollSpecifications';\n  }\n}\n\nmodule.exports = SpecificationsSearchResult;\n","const\n  DocumentSearchResult = require('./searchResult/document');\n\nconst _kuzzle = Symbol();\n\nclass DocumentController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n\n  count (index, collection, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.count: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.count: collection is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'count',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options)\n      .then(response => response.count);\n  }\n\n  create (index, collection, _id, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.create: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.create: collection is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.document.create: body is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'create',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  createOrReplace (index, collection, _id, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.createOrReplace: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.createOrReplace: collection is required');\n    }\n    if (!_id) {\n      throw new Error('Kuzzle.document.createOrReplace: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.document.createOrReplace: body is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'createOrReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  delete (index, collection, _id, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.delete: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.delete: collection is required');\n    }\n    if (!_id) {\n      throw new Error('Kuzzle.document.delete: _id is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      controller: 'document',\n      action: 'delete',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  deleteByQuery(index, collection, body = {}, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.deleteByQuery: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.deleteByQuery: collection is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'deleteByQuery',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  get (index, collection, _id, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.get: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.get: collection is required');\n    }\n    if (!_id) {\n      throw new Error('Kuzzle.document.get: _id is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      controller: 'document',\n      action: 'get',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mCreate (index, collection, documents, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.mCreate: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.mCreate: collection is required');\n    }\n    if (!Array.isArray(documents)) {\n      throw new Error('Kuzzle.document.mCreate: documents must be an array');\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mCreate',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mCreateOrReplace (index, collection, documents, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.mCreateOrReplace: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.mCreateOrReplace: collection is required');\n    }\n    if (!Array.isArray(documents)) {\n      throw new Error('Kuzzle.document.mCreateOrReplace: documents must be an array');\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mCreateOrReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mDelete (index, collection, ids, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.mDelete: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.mDelete: collection is required');\n    }\n    if (!Array.isArray(ids)) {\n      throw new Error('Kuzzle.document.mDelete: ids must be an array');\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {ids},\n      controller: 'document',\n      action: 'mDelete',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mGet (index, collection, ids, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.mGet: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.mGet: collection is required');\n    }\n    if (!Array.isArray(ids)) {\n      throw new Error('Kuzzle.document.mGet: ids must be an array');\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {ids},\n      controller: 'document',\n      action: 'mGet',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mReplace (index, collection, documents, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.mReplace: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.mReplace: collection is required');\n    }\n    if (!Array.isArray(documents)) {\n      throw new Error('Kuzzle.document.mReplace: documents must be an array');\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n    return this.kuzzle.query(request, options);\n  }\n\n  mUpdate (index, collection, documents, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.mUpdate: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.mUpdate: collection is required');\n    }\n    if (!Array.isArray(documents)) {\n      throw new Error('Kuzzle.document.mUpdate: documents must be an array');\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mUpdate',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  replace (index, collection, _id, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.replace: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.replace: collection is required');\n    }\n    if (!_id) {\n      throw new Error('Kuzzle.document.replace: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.document.replace: body is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'replace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  search (index, collection, body = {}, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.search: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.search: collection is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'search',\n    };\n    for (const opt of ['from', 'size', 'scroll', 'includeTrash']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(response => new DocumentSearchResult(this.kuzzle, request, options, response));\n  }\n\n  update (index, collection, _id, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.update: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.update: collection is required');\n    }\n    if (!_id) {\n      throw new Error('Kuzzle.document.update: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.document.update: body is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'update',\n      refresh: options.refresh,\n      retryOnConflict: options.retryOnConflict\n    };\n    delete options.refresh;\n    delete options.retryOnConflict;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  validate (index, collection, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.document.validate: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.document.validate: collection is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.document.validate: body is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'validate'\n    }, options);\n  }\n}\n\nmodule.exports = DocumentController;\n","const\n  SearchResultBase = require('./base');\n\nclass DocumentsSearchResult extends SearchResultBase {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   * @param {object} query\n   * @param {object} options\n   * @param {object} response\n   */\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.searchAction = 'search';\n    this.scrollAction = 'scroll';\n  }\n}\n\nmodule.exports = DocumentsSearchResult;\n","const _kuzzle = Symbol();\n\nclass IndexController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n\n  create (index, options) {\n    if (!index) {\n      throw new Error('Kuzzle.index.create: index is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'create'\n    }, options);\n  }\n\n  delete (index, options) {\n    if (!index) {\n      throw new Error('Kuzzle.index.delete: index is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'delete'\n    }, options);\n  }\n\n  exists (index, options) {\n    if (!index) {\n      throw new Error('Kuzzle.index.exists: index is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'exists'\n    }, options);\n  }\n\n  getAutoRefresh (index, options) {\n    if (!index) {\n      throw new Error('Kuzzle.index.getAutoRefresh: index is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'getAutoRefresh'\n    }, options);\n  }\n\n  list (options) {\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'list'\n    }, options);\n  }\n\n  mDelete (indexes, options) {\n    if (!Array.isArray(indexes)) {\n      throw new Error('Kuzzle.index.mDelete: indexes must be an array');\n    }\n\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'mDelete',\n      body: {\n        indexes\n      }\n    }, options);\n  }\n\n  refresh (index, options) {\n    if (!index || index === '') {\n      throw new Error('Kuzzle.index.refresh: index is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'refresh'\n    }, options);\n  }\n\n  refreshInternal (options) {\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'refreshInternal'\n    }, options);\n  }\n\n  setAutoRefresh (index, autoRefresh, options) {\n    if (!index || index === '') {\n      throw new Error('Kuzzle.index.setAutoRefresh: index is required');\n    }\n\n    if (typeof autoRefresh !== 'boolean') {\n      throw new Error('Kuzzle.index.setAutoRefresh: autoRefresh must be a boolean');\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'setAutoRefresh',\n      body: {\n        autoRefresh\n      }\n    }, options);\n  }\n}\n\nmodule.exports = IndexController;\n","const\n  Room = require('./room'),\n  _kuzzle = Symbol();\n\nclass RealTimeController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n\n    this.subscriptions = {\n      filters: {},\n      channels: {}\n    };\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n\n  count (roomId, options = {}) {\n    if (!roomId) {\n      throw new Error('Kuzzle.realtime.count: roomId is required');\n    }\n\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'count',\n      body: {roomId}\n    }, options)\n      .then(response => response.count);\n  }\n\n  list (options = {}) {\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'list'\n    }, options);\n  }\n\n  publish (index, collection, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.realtime.publish: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.realtime.publish: collection is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.realtime.publish: body is required');\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'publish'\n    };\n\n    return this.kuzzle.query(request, options);\n  }\n\n  subscribe (index, collection, body, callback, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.realtime.subscribe: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.realtime.subscribe: collection is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.realtime.subscribe: body is required');\n    }\n    if (!callback || typeof callback !== 'function') {\n      throw new Error('Kuzzle.realtime.subscribe: a callback function is required');\n    }\n\n    const room = new Room(this.kuzzle, index, collection, body, callback, options);\n\n    return room.subscribe()\n      .then(response => {\n        if (!this.subscriptions[room.id]) {\n          this.subscriptions[room.id] = [];\n        }\n        this.subscriptions[room.id].push(room);\n        return response;\n      });\n  }\n\n  unsubscribe (roomId, options = {}) {\n    if (!roomId) {\n      throw new Error('Kuzzle.realtime.unsubscribe: roomId is required');\n    }\n\n    const rooms = this.subscriptions[roomId];\n\n    if (!rooms) {\n      return Promise.reject(new Error(`not subscribed to ${roomId}`));\n    }\n\n    for (const room of rooms) {\n      room.removeListeners();\n    }\n    delete this.subscriptions[roomId];\n\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'unsubscribe',\n      body: {roomId}\n    }, options);\n  }\n\n  validate (index, collection, body, options = {}) {\n    if (!index) {\n      throw new Error('Kuzzle.realtime.validate: index is required');\n    }\n    if (!collection) {\n      throw new Error('Kuzzle.realtime.validate: collection is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.realtime.validate: body is required');\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'validate'\n    }, options);\n  }\n\n}\n\nmodule.exports = RealTimeController;\n","class Room {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   * @param {string} index\n   * @param {string} collection\n   * @param {object} body\n   * @param {function} callback\n   * @param {object} options\n   */\n  constructor (kuzzle, index, collection, body, callback, options = {}) {\n    this.kuzzle = kuzzle;\n    this.index = index;\n    this.collection = collection;\n    this.callback = callback;\n    this.options = options;\n\n    this.id = null;\n    this.channel = null;\n\n    // format complete request from body & options\n    this.request = {\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'subscribe'\n    };\n    for (const opt of ['state', 'scope', 'users', 'volatile']) {\n      this.request[opt] = this.options[opt];\n      delete this.options[opt];\n    }\n\n    this.autoResubscribe = typeof options.autoResubscribe === 'boolean'\n      ? options.autoResubscribe\n      : kuzzle.autoResubscribe;\n    this.subscribeToSelf = typeof options.subscribeToSelf === 'boolean'\n      ? options.subscribeToSelf\n      : true;\n\n    for (const opt of ['autoResubscribe', 'subscribeToSelf']) {\n      delete this.options[opt];\n    }\n\n    // force bind for further event listener calls\n    this._channelListener = this._channelListener.bind(this);\n    this._reSubscribeListener = this._reSubscribeListener.bind(this);\n  }\n\n  subscribe () {\n    return this.kuzzle.query(this.request, this.options)\n      .then(response => {\n        this.id = response.roomId;\n        this.channel = response.channel;\n\n        // we rely on kuzzle event emitter to not duplicate the listeners here\n        this.kuzzle.network.on(this.channel, this._channelListener);\n\n        this.kuzzle.addListener('reconnected', this._reSubscribeListener);\n\n        return response;\n      });\n  }\n\n  removeListeners () {\n    this.kuzzle.removeListener('reconnected', this._reSubscribeListener);\n\n    if (this.channel) {\n      this.kuzzle.network.removeListener(this.channel, this._channelListener);\n    }\n  }\n\n  _channelListener (data) {\n    const fromSelf = data.volatile !== undefined && data.volatile.sdkInstanceId === this.kuzzle.network.id;\n    if (this.subscribeToSelf || !fromSelf) {\n      this.callback(data);\n    }\n  }\n\n  _reSubscribeListener () {\n    if (this.autoResubscribe) {\n      return this.subscribe();\n    }\n  }\n}\n\nmodule.exports = Room;\n","const _kuzzle = Symbol();\n\n/**\n * @class ServerController\n * @property {Kuzzle} kuzzle - The Kuzzle SDK Instance\n */\nclass ServerController {\n\n  /**\n   * @param {Kuzzle} kuzzle - The Kuzzle SDK Instance\n   */\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n\n  /**\n   * Checks if an administrator user exists\n   *\n   * @param {Object} options - {queuable: Boolean(true)}\n   * @returns {Promise<Boolean>}\n   */\n  adminExists (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'adminExists'\n    }, options)\n      .then(result => {\n        if (typeof result.exists !== 'boolean') {\n          const error = new Error('adminExists: bad response format');\n          error.status = 400;\n          error.response = result;\n          return Promise.reject(error);\n        }\n        return result.exists;\n      });\n  }\n\n\n  /**\n   * Returns all stored statistics frames\n   *\n   * @param {Object} options - {queuable: Boolean(true)}\n   * @returns {Promise<Object>}\n   */\n  getAllStats (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getAllStats'\n    }, options);\n  }\n\n  /**\n   * Returns the Kuzzle configuration\n   *\n   * @param {Object} options - {queuable: Boolean(true)}\n   * @returns {Promise<Object>}\n   */\n  getConfig (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getConfig'\n    }, options);\n  }\n\n  /**\n   * Returns the last statistics frame\n   *\n   * @param {Object} options - {queuable: Boolean(true)}\n   * @returns {Promise<Object>}\n   */\n  getLastStats (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getLastStats'\n    }, options);\n  }\n\n  /**\n   * Returns the statistics frame from a date\n   *\n   * @param {Number|String} startTime - begining of statistics frame set (timestamp or datetime format)\n   * @param {Number|String} stopTime - end of statistics frame set (timestamp or datetime format)\n   * @param {Object} options - {queuable: Boolean(true)}\n   * @returns {Promise<Object>}\n   */\n  getStats(startTime, stopTime, options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getStats',\n      startTime,\n      stopTime\n    }, options);\n  }\n\n  /**\n   * Returns the Kuzzle server information\n   *\n   * @param {Object} options - {queuable: Boolean(true)}\n   * @returns {Promise<Object>}\n   */\n  info (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'info'\n    }, options);\n  }\n\n  /**\n   * Get server's current timestamp\n   *\n   * @param {Object} options - {queuable: Boolean(true)}\n   * @returns {Promise<Number>}\n   */\n  now (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'now'\n    }, options)\n      .then(result => {\n        if (typeof result.now !== 'number') {\n          const error = new Error('now: bad response format');\n          error.status = 400;\n          error.response = result;\n          return Promise.reject(error);\n        }\n        return result.now;\n      });\n  }\n}\n\nmodule.exports = ServerController;\n","const\n  Role = require('./role'),\n  RoleSearchResult = require('../searchResult/role'),\n  Profile = require('./profile'),\n  ProfileSearchResult = require('../searchResult/profile'),\n  User = require('./user'),\n  UserSearchResult = require('../searchResult/user'),\n  _kuzzle = Symbol();\n\n\nclass SecurityController {\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n\n  createCredentials (strategy, _id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.createCredentials: _id is required');\n    }\n    if (!strategy) {\n      throw new Error('Kuzzle.security.createCredentials: strategy is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.createCredentials: body is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      strategy,\n      body,\n      controller: 'security',\n      action: 'createCredentials'\n    }, options);\n  }\n\n  createFirstAdmin (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.createFirstAdmin: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.createFirstAdmin: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'createFirstAdmin',\n      reset: options.reset\n    };\n    delete options.reset;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new User(this.kuzzle, result._id, result._source, result._meta));\n  }\n\n  createOrReplaceProfile (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.createOrReplaceProfile: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.createOrReplaceProfile: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'createOrReplaceProfile',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new Profile(this.kuzzle, result._id, result._source.policies));\n  }\n\n  createOrReplaceRole (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.createOrReplaceRole: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.createOrReplaceRole: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'createOrReplaceRole',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new Role(this.kuzzle, result._id, result._source.controllers));\n  }\n\n  createProfile (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.createProfile: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.createProfile: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'createProfile',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new Profile(this.kuzzle, result._id, result._source.policies));\n  }\n\n  createRole (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.createRole: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.createRole: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'createRole',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new Role(this.kuzzle, result._id, result._source.controllers));\n  }\n\n  createUser (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.createUser: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.createUser: body is required');\n    }\n    if (!body.content) {\n      throw new Error('Kuzzle.security.createUser: body.content is required');\n    }\n    if (!body.credentials) {\n      throw new Error('Kuzzle.security.createUser: body.credentials is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'createUser',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new User(this.kuzzle, result._id, result._source, result._meta));\n  }\n\n  deleteCredentials (strategy, _id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.deleteCredentials: _id is required');\n    }\n    if (!strategy) {\n      throw new Error('Kuzzle.security.deleteCredentials: strategy is required');\n    }\n\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      controller: 'security',\n      action: 'deleteCredentials'\n    }, options);\n  }\n\n  deleteProfile (_id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.deleteProfile: _id is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'deleteProfile'\n    }, options);\n  }\n\n  deleteRole (_id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.deleteRole: _id is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'deleteRole'\n    }, options);\n  }\n\n  deleteUser (_id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.deleteUser: _id is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'deleteUser'\n    }, options);\n  }\n\n  getAllCredentialFields (options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'getAllCredentialFields'\n    }, options);\n  }\n\n  getCredentialFields (strategy, options = {}) {\n    if (!strategy) {\n      throw new Error('Kuzzle.security.getCredentialFields: strategy is required');\n    }\n\n    return this.kuzzle.query({\n      strategy,\n      controller: 'security',\n      action: 'getCredentialFields'\n    }, options);\n  }\n\n  getCredentials (strategy, _id, options = {}) {\n    if (!strategy) {\n      throw new Error('Kuzzle.security.getCredentials: strategy is required');\n    }\n    if (!_id) {\n      throw new Error('Kuzzle.security.getCredentials: _id is required');\n    }\n\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      controller: 'security',\n      action: 'getCredentials'\n    }, options);\n  }\n\n  getCredentialsById (strategy, _id, options = {}) {\n    if (!strategy) {\n      throw new Error('Kuzzle.security.getCredentialsById: strategy is required');\n    }\n    if (!_id) {\n      throw new Error('Kuzzle.security.getCredentialsById: _id is required');\n    }\n\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      controller: 'security',\n      action: 'getCredentialsById'\n    }, options);\n  }\n\n  getProfile (_id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.getProfile: _id is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getProfile'\n    }, options)\n      .then(result => new Profile(this.kuzzle, result._id, result._source.policies));\n  }\n\n  getProfileMapping (options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'getProfileMapping'\n    }, options);\n  }\n\n  getProfileRights (_id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.getProfileRights: _id is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getProfileRights'\n    }, options)\n      .then(result => result.hits);\n  }\n\n  getRole (_id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.getRole: _id is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getRole'\n    }, options)\n      .then(result => new Role(this.kuzzle, result._id, result._source.controllers));\n  }\n\n  getRoleMapping (options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'getRoleMapping'\n    }, options);\n  }\n\n  getUser (_id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.getUser: _id is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getUser'\n    }, options)\n      .then(result => new User(this.kuzzle, result._id, result._source, result._meta));\n  }\n\n  getUserMapping (options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'getUserMapping'\n    }, options);\n  }\n\n  getUserRights (_id, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.getUserRights: _id is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getUserRights'\n    }, options)\n      .then(result => result.hits);\n  }\n\n  hasCredentials (strategy, _id, options = {}) {\n    if (!strategy) {\n      throw new Error('Kuzzle.security.hasCredentials: strategy is required');\n    }\n    if (!_id) {\n      throw new Error('Kuzzle.security.hasCredentials: _id is required');\n    }\n\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      controller: 'security',\n      action: 'hasCredentials'\n    }, options);\n  }\n\n  mDeleteProfiles (ids, options = {}) {\n    if (!Array.isArray(ids)) {\n      throw new Error('Kuzzle.security.mDeleteProfiles: ids must be an array');\n    }\n\n    const request = {\n      controller: 'security',\n      action: 'mDeleteProfiles',\n      body: {ids},\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mDeleteRoles (ids, options = {}) {\n    if (!Array.isArray(ids)) {\n      throw new Error('Kuzzle.security.mDeleteRoles: ids must be an array');\n    }\n\n    const request = {\n      controller: 'security',\n      action: 'mDeleteRoles',\n      body: {ids},\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mDeleteUsers (ids, options = {}) {\n    if (!Array.isArray(ids)) {\n      throw new Error('Kuzzle.security.mDeleteUsers: ids must be an array');\n    }\n\n    const request = {\n      controller: 'security',\n      action: 'mDeleteUsers',\n      body: {ids},\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mGetProfiles (ids, options = {}) {\n    if (!Array.isArray(ids)) {\n      throw new Error('Kuzzle.security.mGetProfiles: ids must be an array');\n    }\n\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'mGetProfiles',\n      body: {ids}\n    }, options)\n      .then(result => result.hits.map(hit => new Profile(this.kuzzle, hit._id , hit._source.policies)));\n  }\n\n  mGetRoles (ids, options = {}) {\n    if (!Array.isArray(ids)) {\n      throw new Error('Kuzzle.security.mGetRoles: ids must be an array');\n    }\n\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'mGetRoles',\n      body: {ids}\n    }, options)\n      .then(result => result.hits.map(hit => new Role(this.kuzzle, hit._id, hit._source.controllers)));\n  }\n\n  replaceUser (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.replaceUser: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.replaceUser: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'replaceUser',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new User(this.kuzzle, result._id, result._source, result._meta));\n  }\n\n  searchProfiles (body, options= {}) {\n    const request = {\n      body,\n      controller: 'security',\n      action: 'searchProfiles'\n    };\n    for (const opt of ['from', 'size', 'scroll']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(result => new ProfileSearchResult(this.kuzzle, request, options, result));\n  }\n\n  searchRoles (body, options = {}) {\n    const request = {\n      body,\n      controller: 'security',\n      action: 'searchRoles'\n    };\n    for (const opt of ['from', 'size']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(result => new RoleSearchResult(this.kuzzle, request, options, result));\n  }\n\n  searchUsers (body, options = {}) {\n    const request = {\n      body,\n      controller: 'security',\n      action: 'searchUsers'\n    };\n    for (const opt of ['from', 'size', 'scroll']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(result => new UserSearchResult(this.kuzzle, request, options, result));\n  }\n\n  updateCredentials (strategy, _id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.updateCredentials: _id is required');\n    }\n    if (!strategy) {\n      throw new Error('Kuzzle.security.updateCredentials: strategy is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.updateCredentials: body is required');\n    }\n\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      body,\n      controller: 'security',\n      action: 'updateCredentials'\n    }, options);\n  }\n\n  updateProfile (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.updateProfile: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.updateProfile: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'updateProfile',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new Profile(this.kuzzle, result._id, result._source.policies));\n  }\n\n  updateProfileMapping (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'security',\n      action: 'updateProfileMapping'\n    }, options);\n  }\n\n  updateRole (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.updateRole: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.updateRole: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'updateRole',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new Role(this.kuzzle, result._id, result._source.controllers));\n  }\n\n  updateRoleMapping (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'security',\n      action: 'updateRoleMapping'\n    }, options);\n  }\n\n  updateUser (_id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.updateUser: _id is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.updateUser: body is required');\n    }\n\n    const request = {\n      _id,\n      body,\n      controller: 'security',\n      action: 'updateUser',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options)\n      .then(result => new User(this.kuzzle, result._id, result._source, result._meta));\n  }\n\n  updateUserMapping (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'security',\n      action: 'updateUserMapping'\n    }, options);\n  }\n\n  validateCredentials (strategy, _id, body, options = {}) {\n    if (!_id) {\n      throw new Error('Kuzzle.security.validateCredentials: _id is required');\n    }\n    if (!strategy) {\n      throw new Error('Kuzzle.security.validateCredentials: strategy is required');\n    }\n    if (!body) {\n      throw new Error('Kuzzle.security.validateCredentials: body is required');\n    }\n\n    return this.kuzzle.query({\n      _id,\n      strategy,\n      body,\n      controller: 'security',\n      action: 'validateCredentials'\n    }, options);\n  }\n}\n\nmodule.exports = SecurityController;\n","const\n  Role = require('../security/role'),\n  SearchResultBase = require('./base');\n\nclass RoleSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.searchAction = 'searchRoles';\n    this.scrollAction = null; // scrollRoles action does not exists in Kuzzle API.\n\n    this.hits = this.response.hits.map(hit => new Role(this.kuzzle, hit._id, hit._source.controllers));\n  }\n\n  next () {\n    // in Kuzzle API, scrollRoles action is not available, and searchRoles allows only from and size parameters\n    // => we deny \"scroll\" and \"sort\" parameters.\n    if (this.request.scroll || this.request.sort) {\n      throw new Error('only from/size params are allowed for role search');\n    }\n\n    return super.next()\n      .then(result => {\n        if (!result) {\n          return result;\n        }\n\n        this.hits = this.response.hits.map(hit => new Role(this.kuzzle, hit._id, hit._source.controllers));\n\n        return this;\n      });\n  }\n}\n\nmodule.exports = RoleSearchResult;\n","const\n  Profile = require('../security/profile'),\n  SearchResultBase = require('./base');\n\nclass ProfileSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, request, options, response) {\n    super(kuzzle, request, options, response);\n\n    this.searchAction = 'searchProfiles';\n    this.scrollAction = 'scrollProfiles';\n    this.hits = response.hits.map(hit => new Profile(this.kuzzle, hit._id, hit._source.policies));\n  }\n\n  next () {\n    return super.next()\n      .then(result => {\n        if (! result) {\n          return result;\n        }\n\n        this.hits = this.response.hits.map(hit => new Profile(this.kuzzle, hit._id, hit._source.policies));\n        return this;\n      });\n  }\n}\n\nmodule.exports = ProfileSearchResult;\n","const\n  SearchResultBase = require('./base'),\n  User = require('../security/user');\n\nclass UserSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.searchAction = 'searchUsers';\n    this.scrollAction = 'scrollUsers';\n    this.hits = this.response.hits.map(hit => new User(this.kuzzle, hit._id, hit._source, hit._meta));\n  }\n\n  next () {\n    return super.next()\n      .then(result => {\n        if (!result) {\n          return result;\n        }\n\n        this.hits = this.response.hits.map(hit => new User(this.kuzzle, hit._id, hit._source, hit._meta));\n        return this;\n      });\n  }\n}\n\nmodule.exports = UserSearchResult;\n","// Parameter mutualization\nconst\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true,\n    required: ['_id', 'cursor'],\n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']};\n\n// Redis commands\nconst\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    flushdb: {mapResults: mapNoResult},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: {required: ['_id', 'field', 'value']},\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n    hscan: getxScan,\n    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n    mget: getKeys,\n    mset: {required: ['entries'], mapResults: mapNoResult},\n    msetnx: {required: ['entries'], mapResults: Boolean},\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: {required: ['_id'], mapResults: Boolean},\n    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\nconst _kuzzle = Symbol();\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nclass MemoryStorageController {\n\n  constructor (kuzzle) {\n    this[_kuzzle] = kuzzle;\n  }\n\n  get kuzzle () {\n    return this[_kuzzle];\n  }\n}\n\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\nfor (const action of Object.keys(commands)) {\n  // eslint-disable-next-line no-loop-func\n  MemoryStorageController.prototype[action] = function (...args) {\n    const\n      command = commands[action],\n      request = {\n        action,\n        controller: 'ms'\n      },\n      options = {};\n\n    if (!command.getter) {\n      request.body = {};\n    }\n\n    for (const param of command.required || []) {\n      const value = args.shift();\n\n      if (value === undefined) {\n        throw new Error(`ms.${action}: missing parameter ${param}`);\n      }\n\n      assignParameter(request, command.getter, param, value);\n    }\n\n    if (args.length > 1) {\n      throw new Error(`ms.${action}: too many parameters provided`);\n    }\n\n    if (args.length) {\n      if (typeof args[0] !== 'object' || Array.isArray(args[0])) {\n        throw new Error(`ms.${action}: invalid optional paramater (expected an object`);\n      }\n\n      Object.assign(options, args[0]);\n\n      if (Array.isArray(command.opts)) {\n        for (const opt of command.opts) {\n          if (options[opt] !== null && options[opt] !== undefined) {\n            assignParameter(request, command.getter, opt, options[opt]);\n            delete options[opt];\n          }\n        }\n      }\n    }\n\n    /*\n     Options function mapper does not necessarily need\n     options to be passed by clients.\n     */\n    if (typeof command.opts === 'function') {\n      command.opts(request, options);\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(res => {\n        if (command.mapResults) {\n          return command.mapResults(res.result);\n        }\n        return res.result;\n      });\n  };\n}\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  const parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions (data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults (results) {\n  return results.map(coords => coords.map(parseFloat));\n}\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    const p = {\n      name: point.shift()\n    };\n\n    for (const elem of point) {\n      if (Array.isArray(elem)) {\n        // withcoord result are in an array...\n        p.coordinates = elem.map(parseFloat);\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(elem);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray(results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt (results) {\n  return results.map(x => parseInt(x));\n}\n\n/**\n * Disable results for routes like flushdb\n * @return {undefined}\n */\nfunction mapNoResult () {}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults (results) {\n  const mapped = [];\n\n  for (let i = 0; i < results.length; i += 2) {\n    mapped.push({\n      member: results[i],\n      score: parseFloat(results[i + 1])\n    });\n  }\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n *\n * @param  {array.<string|array>} results\n * @return {object}\n */\nfunction mapScanResults (results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorageController;\n","/**\n *\n * @param protocol\n * @param host\n * @param options\n * @returns {AbstractWrapper} Instantiated WebSocket/Socket.IO object\n */\n\nfunction network (protocol, options) {\n  switch (protocol) {\n    case 'http':\n      return new (require('./protocols/http'))(options);\n    case 'websocket':\n      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n        throw new Error('Aborting: no websocket support detected.');\n      }\n      return new (require('./protocols/websocket'))(options);\n    case 'socketio':\n      if (!window.io) {\n        throw new Error('Aborting: no socket.io library loaded.');\n      }\n      return new (require('./protocols/socketio'))(options);\n    default:\n      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"http\", \"websocket\" and \"socketio\" are available).');\n  }\n}\n\nmodule.exports = network;\n","'use strict';\n\nconst\n  AbtractWrapper = require('./abstract/common');\n\nconst\n  _routes = {\n    routes: {\n      auth: {\n        login: {\n          verb: 'POST',\n          url: '/_login/:strategy'\n        }\n      },\n      bulk: {\n        import: {\n          verb: 'POST',\n          url: '/:index/:collection/_bulk'\n        }\n      },\n      document: {\n        create: {\n          verb: 'POST',\n          url: '/:index/:collection/_create'\n        }\n      },\n      security: {\n        createFirstAdmin: {\n          verb: 'POST',\n          url: '/_createFirstAdmin'\n        },\n        createRestrictedUser: {\n          verb: 'POST',\n          url: '/users/_createRestricted'\n        },\n        createUser: {\n          verb: 'POST',\n          url: '/users/_create'\n        }\n      }\n    }\n  };\n\n\nclass HttpWrapper extends AbtractWrapper {\n\n  constructor(options = {}) {\n    super(options);\n\n    if (typeof this.host !== 'string' || this.host === '') {\n      throw new Error('options.host is required');\n    }\n\n    // Application-side HTTP route overrides:\n    if (options.http && options.http.customRoutes) {\n      for (const controller in options.http.customRoutes) {\n        if (options.http.customRoutes.hasOwnProperty(controller)) {\n          this.http.routes[controller] = Object.assign(this.http.routes[controller] || {}, options.http.customRoutes[controller]);\n        }\n      }\n    }\n  }\n\n  get http () {\n    return _routes;\n  }\n\n  get protocol () {\n    return this.ssl ? 'https' : 'http';\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    if (this.state === 'ready') {\n      return Promise.resolve();\n    }\n\n    return this._sendHttpRequest('GET', '/')\n      .then(res => {\n        // Get HTTP Routes from Kuzzle serverInfo\n        // (if more than 1 available route for a given action, get the first one):\n        const routes = res.result.serverInfo.kuzzle.api.routes;\n        for (const controller of Object.keys(routes)) {\n          if (this.http.routes[controller] === undefined) {\n            this.http.routes[controller] = {};\n          }\n\n          for (const action of Object.keys(routes[controller])) {\n            if (this.http.routes[controller][action] === undefined\n              && Array.isArray(routes[controller][action].http)\n              && routes[controller][action].http.length > 0) {\n\n              this.http.routes[controller][action] = routes[controller][action].http[0];\n            }\n          }\n        }\n\n        // Client is ready\n        this.clientConnected();\n      })\n      .catch(err => {\n        const connectionError = new Error(`Unable to connect to kuzzle server at ${this.host}:${this.port}`);\n        connectionError.internal = err;\n\n        this.emit('networkError', connectionError);\n        throw err;\n      });\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} data\n   * @returns {Promise<any>}\n   */\n  send (data) {\n    const\n      payload = {\n        action: undefined,\n        body: undefined,\n        collection: undefined,\n        controller: undefined,\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        index: undefined,\n        meta: undefined,\n        requestId: undefined,\n      },\n      queryArgs = {};\n\n    for (const key of Object.keys(data)) {\n      const value = data[key];\n\n      if (key === 'body') {\n        payload.body = JSON.stringify(value);\n      }\n      else if (key === 'jwt') {\n        payload.headers.authorization = 'Bearer ' + value;\n      }\n      else if (key === 'volatile') {\n        payload.headers['x-kuzzle-volatile'] = JSON.stringify(value);\n      }\n      else if (payload.hasOwnProperty(key)) {\n        payload[key] = value;\n      }\n      else {\n        queryArgs[key] = value;\n      }\n    }\n\n    payload.headers['Content-Length'] = Buffer.byteLength(payload.body || '');\n\n    const\n      route = this.http.routes[payload.controller] && this.http.routes[payload.controller][payload.action];\n\n    if (route === undefined) {\n      const error = new Error(`No route found for ${payload.controller}/${payload.action}`);\n      this.emit(payload.requestId, {status: 400, error});\n    }\n\n    const\n      method = route.verb,\n      regex = /\\/:([^/]*)/;\n\n    let\n      url = route.url,\n      matches = regex.exec(url);\n\n    while (matches) {\n      url = url.replace(regex, '/' + data[ matches[1] ]);\n      delete(queryArgs[ matches[1] ]);\n      matches = regex.exec(url);\n    }\n\n    // inject queryString arguments:\n    const queryString = [];\n    for (const key of Object.keys(queryArgs)) {\n      const value = queryArgs[key];\n\n      if (Array.isArray(value)) {\n        queryString.push(...value.map(v => `${key}=${v}`));\n\n      }\n      else {\n        queryString.push(`${key}=${value}`);\n      }\n    }\n\n    if (queryString.length > 0) {\n      url += '?' + queryString.join('&');\n    }\n\n    this._sendHttpRequest(method, url, payload)\n      .then(response => this.emit(payload.requestId, response))\n      .catch(error => this.emit(payload.requestId, {error}));\n  }\n\n  _sendHttpRequest (method, path, payload = {}) {\n    if (typeof XMLHttpRequest === 'undefined') {\n      // NodeJS implementation, using http.request:\n\n      const httpClient = require('min-req-promise');\n      const url = `${this.protocol}://${this.host}:${this.port}${path}`;\n\n      return httpClient.request(url, method, {\n        headers: payload.headers,\n        body: payload.body\n      })\n        .then(response => JSON.parse(response.body));\n    }\n\n    // Browser implementation, using XMLHttpRequest:\n    return new Promise((resolve, reject) => {\n      const\n        xhr = new XMLHttpRequest(),\n        url = `${this.protocol}://${this.host}:${this.port}${path}`;\n\n      xhr.open(method, url);\n\n      for (const header of Object.keys(payload.headers || {})) {\n        xhr.setRequestHeader(header, payload.headers[header]);\n      }\n\n      xhr.onload = () => {\n        try {\n          const json = JSON.parse(xhr.responseText);\n          resolve(json);\n        }\n        catch (err) {\n          reject(err);\n        }\n      };\n\n      xhr.send(payload.body);\n    });\n  }\n\n}\n\nfor (const prop of [\n  'protocol'\n]) {\n  Object.defineProperty(HttpWrapper.prototype, prop, {enumerable: true});\n}\n\nmodule.exports = HttpWrapper;\n","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nlet WebSocketClient;\n\nclass WSNode extends RTWrapper {\n\n  constructor(options = {}) {\n    super(options);\n\n    if (typeof this.host !== 'string' || this.host === '') {\n      throw new Error('options.host is required');\n    }\n\n    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : require('uws');\n    this.client = null;\n    this.lasturl = null;\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    return new Promise((resolve, reject) => {\n      const\n        url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n        opts = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n      super.connect();\n\n      if (url !== this.lasturl) {\n        this.wasConnected = false;\n        this.lasturl = url;\n      }\n\n      this.client = new WebSocketClient(url, opts);\n\n      this.client.onopen = () => {\n        this.clientConnected();\n        return resolve();\n      };\n\n      this.client.onclose = (closeEvent, message) => {\n        let\n          status,\n          reason = message;\n\n        if (typeof closeEvent === 'number') {\n          status = closeEvent;\n        }\n        else {\n          status = closeEvent.code;\n\n          if (closeEvent.reason) {\n            reason = closeEvent.reason;\n          }\n        }\n\n        if (status === 1000) {\n          this.clientDisconnected();\n        }\n        // do not forward a connection close error if no\n        // connection has been previously established\n        else if (this.wasConnected) {\n          const error = new Error(reason);\n          error.status = status;\n\n          this.clientNetworkError(error);\n        }\n      };\n\n      this.client.onerror = error => {\n        const err = (error instanceof Error) && error || new Error(error);\n\n        this.clientNetworkError(err);\n\n        if ([this.client.CLOSING, this.client.CLOSED].indexOf(this.client.readyState) > -1) {\n          return reject(err);\n        }\n      };\n\n      this.client.onmessage = payload => {\n        const data = JSON.parse(payload.data || payload);\n\n        // for responses, data.room == requestId\n        if (data.room) {\n          this.emit(data.room, data);\n        }\n        else {\n          this.emit('discarded', data);\n        }\n      };\n\n    });\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.state = 'offline';\n    this.removeAllListeners();\n    this.wasConnected = false;\n    if (this.client) {\n      this.client.close();\n    }\n    this.client = null;\n    this.stopRetryingToConnect = true;\n    super.close();\n  }\n}\n\nmodule.exports = WSNode;\n","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nclass SocketIO extends RTWrapper {\n\n  constructor(options = {}) {\n    super(options);\n\n    if (typeof this.host !== 'string' || this.host === '') {\n      throw new Error('options.host is required');\n    }\n\n    this.socket = null;\n    this.forceDisconnect = false;\n    this.eventsWrapper = {};\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   */\n  connect () {\n    return new Promise((resolve, reject) => {\n      super.connect();\n\n      this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n        reconnection: this.autoReconnect,\n        reconnectionDelay: this.reconnectionDelay,\n        forceNew: true\n      });\n\n      this.socket.on('connect', () => resolve(this.clientConnected()));\n      this.socket.on('connect_error', error => {\n        this.clientNetworkError(error);\n        reject(error);\n      });\n\n      this.socket.on('disconnect', () => {\n        if (this.forceDisconnect) {\n          this.clientDisconnected();\n        } else {\n          const error = new Error('An error occurred, kuzzle may not be ready yet');\n          error.status = 500;\n\n          this.clientNetworkError(error);\n          reject(error);\n        }\n\n        this.forceDisconnect = false;\n      });\n\n    });\n  }\n\n  /**\n   * Registers a callback on an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   * @param {boolean} once\n   */\n  addListener (event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    super.addListener(event, callback, once);\n\n    return this;\n  }\n\n  prependListener (event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    return super.prependListener(event, callback, once);\n  }\n\n  /**\n   * Unregisters a callback from an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  removeListener (event, callback) {\n    if (this.eventsWrapper[event]) {\n      this.eventsWrapper[event].listeners.delete(callback);\n\n      if (this.eventsWrapper[event].listeners.size === 0) {\n        this.socket.off(event, this.eventsWrapper[event].wrapper);\n        delete this.eventsWrapper[event];\n      }\n\n      super.removeListener(event, callback);\n    }\n\n    return this;\n  }\n\n  /**\n   * Unregisters all listeners either from an event, or from all events\n   *\n   * @param {string} [event]\n   */\n  removeAllListeners (event) {\n    if (event !== undefined) {\n      if (this.eventsWrapper[event] !== undefined) {\n        for (const listener of this.eventsWrapper[event].listeners) {\n          this.removeListener(event, listener);\n        }\n      }\n    } else {\n      for (const _event of Object.keys(this.eventsWrapper)) {\n        this.removeAllListeners(_event);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send(payload) {\n    this.socket.emit('kuzzle', payload);\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.forceDisconnect = true;\n    this.state = 'offline';\n    this.socket.close();\n    this.socket = null;\n    super.close();\n  }\n\n  _addEventWrapper (event, callback, once = false) {\n    if (!this.eventsWrapper[event]) {\n      const wrapper = (...args) => this.emit(event, ...args);\n\n      this.eventsWrapper[event] = {\n        wrapper,\n        listeners: new Set()\n      };\n\n      if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n        if (once) {\n          this.socket.once(event, wrapper);\n        } else {\n          this.socket.on(event, wrapper);\n        }\n      }\n    }\n\n    this.eventsWrapper[event].listeners.add(callback);\n  }\n}\n\nmodule.exports = SocketIO;\n"],"sourceRoot":""}